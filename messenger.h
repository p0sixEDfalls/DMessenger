#include <queue>
#include <mutex>

#define MESS_PORT "5555"
#define MAX_MSG_LEN 1024

static const unsigned char verifyMagic[304] =
{
	0x4d,  0x6d,  0x6d,  0x2c,  0x20,  0x62,  0x61,  0x62,  0x79,  0x2c,  0x20,  0x49,  0x20,  0x64,  0x6f,  0x6e,\
	0x27,  0x74,  0x20,  0x75,  0x6e,  0x64,  0x65,  0x72,  0x73,  0x74,  0x61,  0x6e,  0x64,  0x20,  0x74,  0x68,\
	0x69,  0x73,  0x0a,  0x59,  0x6f,  0x75,  0x27,  0x72,  0x65,  0x20,  0x63,  0x68,  0x61,  0x6e,  0x67,  0x69,\
	0x6e,  0x67,  0x2c,  0x20,  0x49,  0x20,  0x63,  0x61,  0x6e,  0x27,  0x74,  0x20,  0x73,  0x74,  0x61,  0x6e,\
	0x64,  0x20,  0x69,  0x74,  0x0a,  0x4d,  0x79,  0x20,  0x68,  0x65,  0x61,  0x72,  0x74,  0x20,  0x63,  0x61,\
	0x6e,  0x27,  0x74,  0x20,  0x74,  0x61,  0x6b,  0x65,  0x20,  0x74,  0x68,  0x69,  0x73,  0x20,  0x64,  0x61,\
	0x6d,  0x61,  0x67,  0x65,  0x0a,  0x41,  0x6e,  0x64,  0x20,  0x74,  0x68,  0x65,  0x20,  0x77,  0x61,  0x79,\
	0x20,  0x49,  0x20,  0x66,  0x65,  0x65,  0x6c,  0x2c,  0x20,  0x63,  0x61,  0x6e,  0x27,  0x74,  0x20,  0x73,\
	0x74,  0x61,  0x6e,  0x64,  0x20,  0x69,  0x74,  0x0a,  0x4d,  0x6d,  0x6d,  0x2c,  0x20,  0x62,  0x61,  0x62,\
	0x79,  0x2c,  0x20,  0x49,  0x20,  0x64,  0x6f,  0x6e,  0x27,  0x74,  0x20,  0x75,  0x6e,  0x64,  0x65,  0x72,\
	0x73,  0x74,  0x61,  0x6e,  0x64,  0x20,  0x74,  0x68,  0x69,  0x73,  0x0a,  0x59,  0x6f,  0x75,  0x27,  0x72,\
	0x65,  0x20,  0x63,  0x68,  0x61,  0x6e,  0x67,  0x69,  0x6e,  0x67,  0x2c,  0x20,  0x49,  0x20,  0x63,  0x61,\
	0x6e,  0x27,  0x74,  0x20,  0x73,  0x74,  0x61,  0x6e,  0x64,  0x20,  0x69,  0x74,  0x0a,  0x4d,  0x79,  0x20,\
	0x68,  0x65,  0x61,  0x72,  0x74,  0x20,  0x63,  0x61,  0x6e,  0x27,  0x74,  0x20,  0x74,  0x61,  0x6b,  0x65,\
	0x20,  0x74,  0x68,  0x69,  0x73,  0x20,  0x64,  0x61,  0x6d,  0x61,  0x67,  0x65,  0x0a,  0x41,  0x6e,  0x64,\
	0x20,  0x74,  0x68,  0x65,  0x20,  0x77,  0x61,  0x79,  0x20,  0x49,  0x20,  0x66,  0x65,  0x65,  0x6c,  0x2c,\
	0x20,  0x63,  0x61,  0x6e,  0x27,  0x74,  0x20,  0x73,  0x74,  0x61,  0x6e,  0x64,  0x20,  0x69,  0x74,  0x0a,\
	0x4d,  0x6d,  0x6d,  0x2c,  0x20,  0x62,  0x61,  0x62,  0x79,  0x2c,  0x20,  0x49,  0x20,  0x64,  0x6f,  0x6e,\
	0x27,  0x74,  0x20,  0x75,  0x6e,  0x64,  0x65,  0x72,  0x73,  0x74,  0x61,  0x6e,  0x64,  0x20,  0x69,  0x74
};

typedef pair<int, unsigned int> event;

class Dialog;

struct verifyMsg
{
	int magic;
	vector<unsigned char> vPubKey;
	vector<unsigned char> vSign;
};

struct message
{
	bool isMine;
	uint64 time;
	string msg;
};

extern verifyMsg vm;

void StartThreadConnection();
void StartThreadAccept(SOCKET * pListenSocket);
void StartThreadMessagesR();
void StartThreadMessagesS();

void ThreadConnection();
void ThreadAccept(SOCKET * pListenSocket);
void ThreadMessagesR();
void ThreadMessagesS();
int StartMess();
Dialog* ConnectDialog(CAddress& addrConnect, verifyMsg* vm);
bool GenerateSign(verifyMsg* vm);
inline bool GenerateSign(verifyMsg* vm);
bool SendMessageM(uint160 hash, string& msg);

void PrintDialogs();
void clear();
void PrintMessages(char nDiag);
bool SendMessageC(char nDiag, string& msg);
bool SetKey(uint160 hash, unsigned char * keyStr, int keyLen);
bool GetMyExternalIP3(CAddress& addr);


enum
{
	NEW_CNCT = 1,
};

template <typename T>
class ThreadSafeVector
{
private:
	mutex mtx;
	
public:
	vector <T> elements;

	ThreadSafeVector()
	{
		elements.clear();
	}

	void pushBack(T e)
	{
		elements.push_back(e);
	}

	void pop()
	{
		elements.erase(elements.begin());
	}

	void front(T& element)
	{
		if (elements.size() > 0)
			element = elements.at(0);
		else
			element = make_pair(NULL, NULL);
	}

	vector<T>& getVector()
	{
		return elements;
	}

	void lock()
	{
		mtx.lock();
	}

	void unlock()
	{
		mtx.unlock();
	}
};

class Dialog
{
public:
	SOCKET hSocket;
	CAddress dialogIP;
	uint160 hash;
	CDataStream messagesS;
	CDataStream messagesR;
	vector<message> vMessages;
	int unReadMsg;
	bool sendVerif;
	EVP_CIPHER_CTX en, de;

	Dialog(SOCKET socket, CAddress addr)
	{
		hSocket = socket;
		dialogIP = addr;
		hash = 0;
		unReadMsg = 0;
		sendVerif = false;
		messagesS.SetType(SER_NETWORK);
		messagesR.SetType(SER_NETWORK);
		vMessages.clear();
		messagesS << vm.magic << vm.vPubKey << vm.vSign;
	}

	bool IsVerify()
	{
		if (hash == 0)
			return false;
		return true;
	}

	void Disconect()
	{
		closesocket(hSocket);
	}

	bool Verify()
	{
		verifyMsg vm;
		messagesR >> vm.magic >> vm.vPubKey >> vm.vSign;
		CKey key1;
		key1.SetPubKey(vm.vPubKey);
		if (vm.magic != 0xabadbabe)
		{
			printf("error magic\n");
			messagesR.clear();
			return false;
		}
		if (key1.Verify(verifyMagic, sizeof(verifyMagic), vm.vSign))
		{ 
			hash = Hash160(vm.vPubKey);
			messagesR.clear();
			return true;
		}
		messagesR.clear();
		return false;
	}
};
